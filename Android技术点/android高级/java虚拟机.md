### java虚拟机

![虚拟机](..\images\虚拟机.jpg)

[Toc]

#### java的内存模型：

```
1，堆（线程共享）
   1）JVM管理的最大的一块内存区域，存放着对象的实例，是线程共享区。
   2）堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。
   3）JAVA堆的分类
   从内存回收的角度上看，可分为新生代（Eden空间，From Survivor空间、To Survivor空间）及老年代（Tenured Gen），JAVA堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。可通过参数 -Xmx -Xms 来指定运行时堆内存的大小，堆内存空间不足也会抛OutOfMemoryError异常。
2，栈（线程私有）
    1）虚拟机栈（存放运行时所需的数据，栈帧），本地方法栈（JVM所调用到的native，本地方法服务）
    2）每个线程有一个私有的栈，随着线程的创建而创建，生命周期与线程相同。
    3）虚拟机栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的各种基本数据类型和对象引用类型。通常我们所说的“栈内存”指的就是局部变量表这一部分。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧分配多少内存是固定的，运行期间不会改变局部变量表的大小。
    4）栈的大小可以固定也可以动态扩展。
    在固定大小的情况下，当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError异常。在动态扩展的情况下，若扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
    5）本地方法栈：
    和虚拟机栈类似，两者的区别就是虚拟机栈是为虚拟机执行java方法服务，本地方法栈为虚拟机执行native方法服务。HotSpot虚拟机不区分虚拟机栈和本地方法栈，两者是一块的。与虚拟机栈一样，本地方法栈也会抛StackOverflowError和OutOfMemoryError异常。
3，方法区（线程共享）
    1）方法区也是线程共享区，用于存储【虚拟机加载的类信息（类的版本、字段、方法、接口），常量，静态变量，即时编译器编译后的代码等数据】
    2）方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。
    3）HotSpot虚拟机使用永久代来实现方法区，使得HotSpot虚拟机的垃圾收集器可以像管理堆内存一样来管理这部分内存，能省去专门为方法区编写内存管理代码工作。所以开发者喜欢将方法区称为永久代，本质上两者并不等价，对于其他虚拟机来说不存在永久代的概念。
    4）方法区可选择不实现垃圾收集，一般来说，这个区域对内存回收的条件较为苛刻，但是这部分区域的回收确实是必要的。
    5）当方法区无法满足内存分配需求时，将会抛OutOfMemoryError异常。
    6）运行时常量池：运行时常量池是方法区的一部分，class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后加入方法区的运行时常量池中存放。
    运行时常量池相于class文件中的常量池，所不同的是其具备了动态性。class文件中常量池中的常量在编译期间就已经定义好了，而运行时常量池在程序运行期间也可以将常量放入该常量池中，最常见的做法就是调用String类的intern()方法。
4，程序计数器（线程私有）
    1）程序计数器是一块较小的空间，它可以看作是当前线程所执行的字节码的行号指示器。
    2）如果线程执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址（可以理解为行号），如果正在执行的是native方法，这个计数器的值为undefined。
    3）JVM的多线程是通过线程轮流切换并分配CPU执行时间片的方式来实现的，任何一个时刻，一个CPU都只会执行一条线程中的指令。为了保证线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程间的程序计数器独立存储，互不影响。
    4）此区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域，因为程序计数器是由虚拟机内部维护的，不需要开发者进行操作。
```


#### GC判定算法

##### 引用计数法（已经被废弃）

给对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加1;当引用失效时,计数器值就减1;任何时刻计数器为0的对象就是不可能再被使用的。

目前主流的java虚拟机都摒弃掉了这种算法，最主要的原因是它很难解决对象 
之间相互循环引用的问题。尽管该算法执行效率很高。

##### 根搜索算法（GC Roots）

目前主流的编程语言(java,C#等)的主流实现中,都是称通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。

##### GC Roots
- 虚拟机栈(栈帧中的本地变量表)中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI(即一般说的Native方法)引用的对象。

#### GC回收算法

##### 复制算法

将整个内存分为两部分，一部分用来为对象分配内存，另一部分用来将存活的对象复制过去，方便回收可回收对象（复制过去后，直接回收另一部分的所有对象即可）；适用于存活对象少，大量短期对象的情况。(因为复制大量存活的对象很花费时间)

##### 标记清除算法

从根节点开始向下扫描，将能够查询到的对象进行标记，然后回收未标记处即可；会产生大量内存碎片；

##### 标记整理算法

与标记-清除算法相同，都是先标记从GC Roots向下查询到的对象，然后对未标记的对象进行回收，但是不同的是标记-整理算法最后会将所有存活对象整理到一端，减少了内存碎片

#### 垃圾分代逻辑
整个java堆可以切割成三部分：

```
1 Young(年轻代)：
    1）Eden(伊利园)：存放新生对象
    2）Survivor(幸存者)：存放经过垃圾回收没有被清除的对象
    3）一般占据堆的1/3空间，新生成的对象存在新生代，新生代对象存活率比较低，在新生代，进行一次垃圾回收可以回收70%~90%。
    4）Hotspot将新生代划分为三块（Eden空间和两块较小的Survivor空间，默认比例是8:1:1,目的是采用复制算法进行回收）
    5）新生成的对象在Eden区域分配（大对象除外，大对象直接进入老年代），当Eden区没有足够的空间分配时，将进行一次Minor GC。
    6）GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor是空的(同一时刻，Surivor只有一个在用，一个是空的)
    7）GC进行时，Eden区所有存活都会到To Survivor中，而在From Survivor中的对象会根据年龄值决定去留，年龄值达到阈值（默认为15，新生代每熬过一次垃圾回收，年龄加1，GC分代年龄存在对象的header中）的对象会被移动到老年代，没有达到年龄阈值的对象会被移动到To Survivor中，接着清空Eden和From Survivor区。新生代存活的对象都会被复制到To Survivor中。
    8）接着，From Survivor区和To Survivor区会交换他们的角色，总之要保证To Sruvivor区在一轮GC后，是空的，当To Survivor区没有足够空间来存放新生代上一次回收存活下来的对象时，需要依赖老年代来担保，将这些对象放到老年代。
2 Tenured(老年代)：
    老年代中的对象生命周期比较长，存活率比较高，在老年代进行GC的频率也相对较低，而且回收速度也相对较慢。
3 Perm(永久代):
    主要存放Class和Meta（元数据）的信息。
    1）Class在被加载的时候被放入永久区域。它和和存放实例的区域不同，GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。
    在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。
    2）元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中. 这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。
```

#### GC会造成什么影响？
stop-the-world。不管选择哪种GC算法，stop-the-world都是不可避免的。
也就是说，当垃圾回收开始清理资源时，其余的所有线程都会被停止。所以，我们要做的就是尽可能的让它执行的时间变短。如果清理的时间过长，在我们的应用程序中就能感觉到明显的卡顿。

#### 什么情况下进行GC？

总的来说，有两个条件触发GC：

1，当应用程序空闲时,即没有应用线程在运行时,GC会被调用。因为GC在优先级最低的线程中进行,所以当应用忙时,GC线程就不会被调用,但以下条件除外。

2，Java堆内存不足时,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,JVM会再进行两次GC作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。

由于是否进行主GC由JVM根据系统环境决定,而系统环境在不断的变化当中,所以主GC的运行具有不确定性,无法预计它何时必然出现,但可以确定的是对一个长期运行的应用来说,其主GC是反复进行的。

#### 被GC判断为”垃圾”的对象一定会回收吗?

即使在可达性分析算法中不可达的对象,也并非是“非死不可”的,这时候它们暂时处于“缓刑”阶段,要真正宣告一个对象死亡,至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)

如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中,并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法,但并不承诺会等待它运行结束,这样做的原因是,如果一个对象在finalize()方法中执行缓慢,或者发生了死循环(更极端的情况),将很可能会导致F-Queue队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃。

finalize()方法是对象逃脱死亡命运的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可,譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱,那基本上它就真的被回收了。

#### 示例代码：


```
public class GCTest {
    public static GCTest object = null;

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        GCTest.object = this;
    }

    public static void main(String[] args){
        object = new GCTest();
        // 第一次自救
        objectTest();

        //第二次自救
        objectTest();
    }

    private static void objectTest(){
        object = null;
        System.gc();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (object != null) {
            System.out.println("I am still alive:)");
        } else {
            System.out.println("I am dead:(");
        }
    }
}
```


#### Full GC触发时机：

```
   1）调用System.gc时，系统建议执行Full GC，但是不必然执行
　　2）老年代空间不足
　　3）方法区空间不足
　　4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
　　5）由Eden区、survivor space1（From Space）区向survivor space2（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。
```


#### 问题：
    1，GC搜索算法有哪些？
    2，GC回收算法有哪些？
    3，什么样的数据会跑到永久代？
    4，GC时，遇到垃圾就会马上回收么？
    5，哪些对象可以作为GC Roots?

  内存管理小技巧:
　　1）尽量使用直接量，eg：String javaStr = "小学徒的成长历程";
　　2）使用StringBuilder和StringBuffer进行字符串连接等操作;
　　3）尽早释放无用对象;
　　4）尽量少使用静态变量;
　　5）缓存常用的对象:可以使用开源的开源缓存实现，eg：OSCache，Ehcache;
　　6）尽量不使用finalize()方法;
　　7）在必要的时候可以考虑使用软引用SoftReference。



#### 性能调优：

- **线程池**：解决用户响应时间长的问题

- **连接池**

- **JVM启动参数**：调整各代的内存比例和垃圾回收算法，提高吞吐量

- **程序算法**：改进程序逻辑算法提高性能

   

#### JVM类加载机制

> 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发生顺序如图：
>
> ![这里写图片描述](https://img-blog.csdn.net/20170907001317206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> https://blog.csdn.net/SilenceOO/article/details/77876123

#### 类加载器的双亲委派机制

当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。作用：可以保证java核心库或第三方库的安全（防止低一级加载器加载的类覆盖高级加载器加载的类） 

主要体现在ClassLoader的loadClass()方法中，思路很简单：先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，调用自己的findClass()方法进行加载。



#### 类的五个加载过程,以Person person = new Person()为例描述

1.加载:根据查找路径找到相应的class文件,然后导入。类的加载方式分为 ...
2.检查:检查夹加载的class文件的正确性。
3.准备;给类中的静态变量分配内存空间。
4.解析:虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示,而在直接引用直接指向内存中的地址。
5.初始化:对静态变量和静态代码块执行初始化工作。

https://www.jianshu.com/p/3ca14ec823d7

#### java类加载器的加载流程。

**Person person = new Person();这句话到底做了什么事情呢？** 

1.javac编译.java源文件形成.class字节码文件; 
2.new  Person() 对象时， 先检查有没有父类， 有父类， 类加载器(ClassLoader)先将父类的Class文件读入内存， 创建一个java.lang.Class对象，然后加载子类，类加载器将子类的Class文件读入内存，创建一个java.lang.Class对象;
3.先初始化父类的静态属性，再初始化父类的静态代码块； 
4.再初始化子类的静态属性，再初始化子类的静态代码； 
5.在堆内存中分配内存空间，分配内存地址，此时是因为父类的特有属性才在堆内存中为父类对象分配空间。 
6.初始化父类的特有属性。 
7.初始化父类的构造代码块。 
8.初始化父类对象相应的构造方法。 
9.在堆内存中分配内存空间，分配内存地址，此时是因为子类的特有属性才在堆内存中为子类对象分配空间的。 
10.初始化子类的特有属性。 
11.初始化子类的构造代码块。 
12.初始化子类相应的构造方法。 
13.将子类的内存地址赋值给栈中的引用对象。



#### 参考链接：

 https://blog.csdn.net/qq906627950/article/details/81324825
 https://www.jianshu.com/p/214e42fc0d37
 https://blog.csdn.net/qq_41051923/article/details/106135330
 https://www.cnblogs.com/cuijj/p/10499621.html
 https://blog.csdn.net/canot/article/details/51037938
 https://blog.csdn.net/a602519773/article/details/82529240

 [JVM性能调优](https://www.cnblogs.com/csniper/p/5592593.html)