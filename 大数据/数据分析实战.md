## 数据分析基础

### 数据分析总体概述

#### 数据采集

![](images\数据采集.jpg)

#### 数据挖掘

数据挖掘的核心是挖掘数据的商业价值，也就是我们所谈的商业智能 BI。

![](images\数据挖掘.jpg)

#### 数据可视化

![](images\数据可视化.jpg)

#### 修炼指南

我们只有把知识转化为自己的语言，它才真正变成了我们自己的东西

学习理论知识，提升认知；熟悉工具操作；多练习实践

### 数据挖掘学习路径

数据挖掘的基本流程、十大算法和数学原理

#### 基本流程

1. 商业理解：从商业的角度理解项目需求，再对数据挖掘的目标进行定义。
2. 数据理解：尝试收集部分数据，然后对数据进行探索，包括数据描述、数据质量验证等。这有助于你对收集的数据有个初步的认知。
3. 数据准备：开始收集数据，并对数据进行清洗、数据集成等操作，完成数据挖掘前的准备工作。
4. 模型建立：选择和应用各种数据挖掘模型，并进行优化，以便得到更好的分类结果。
5. 模型评估：对模型进行评价，并检查构建模型的每个步骤，确认模型是否实现了预定的商业目标。
6. 上线发布：呈现的形式可以是一份报告，也可以是实现一个比较复杂的、可重复的数据挖掘过程

#### 十大算法

分成四类:

- 分类算法：C4.5，朴素贝叶斯（Naive Bayes），SVM，KNN，Adaboost，CARTl 
- 聚类算法：K-Means，EMl 
- 关联分析：Aprioril 
- 连接分析：PageRank

##### 1. C4.5

C4.5 是决策树的算法，它创造性地在决策树构造过程中就进行了剪枝，并且可以处理连续的属性，也能对不完整的数据进行处理

##### 2.朴素贝叶斯（Naive Bayes）

对于给出的未知物体想要进行分类，就需要求解在这个未知物体出现的条件下各个类别出现的概率，哪个最大，就认为这个未知物体属于哪个分类。

##### 3. SVM

SVM 的中文叫支持向量机，英文是 Support Vector Machine，简称 SVM。SVM 在训练中建立了一个超平面的分类模型

##### 4. KNN

KNN 也叫 K 最近邻算法，英文是 K-Nearest Neighbor。所谓 K 近邻，就是每个样本都可以用它最接近的 K 个邻居来代表。

##### 5. AdaBoost

Adaboost 在训练中建立了一个联合的分类模型，是个构建分类器的提升算法。它可以让我们多个弱的分类器组成一个强的分类器，所以 Adaboost 也是一个常用的分类算法。

##### 6. CART

CART 代表分类和回归树，英文是 Classification and Regression Trees。像英文一样，它构建了两棵树：一棵是分类树，另一个是回归树。和 C4.5 一样，它是一个决策树学习方法。

##### 7. Apriori

Apriori 是一种挖掘关联规则（association rules）的算法，它通过挖掘频繁项集（frequent item sets）来揭示物品之间的关联关系，被广泛应用到商业挖掘和网络安全等领域中。频繁项集是指经常出现在一起的物品的集合，关联规则暗示着两种物品之间可能存在很强的关系。

##### 8. K-Means

K-Means 算法是一个聚类算法。

##### 9. EM

EM 算法也叫最大期望算法，是求参数的最大似然估计的一种方法。原理是这样的：假设我们想要评估参数 A 和参数 B，在开始状态下二者都是未知的，并且知道了 A 的信息就可以得到 B 的信息，反过来知道了 B 也就得到了 A。可以考虑首先赋予 A 某个初值，以此得到 B 的估值，然后从 B 的估值出发，重新估计 A 的取值，这个过程一直持续到收敛为止。

EM 算法经常用于聚类和机器学习领域中。

##### 10. PageRank

PageRank 起源于论文影响力的计算方式，如果一篇文论被引入的次数越多，就代表这篇论文的影响力越强。PageRank 被 Google 创造性地应用到了网页权重的计算中，当一个页面链出的页面越多，说明这个页面的“参考文献”越多，当这个页面被链入的频率越高，说明这个页面被引用的次数越高

### 数据挖掘的数学原理

#### 1. 概率论与数理统计

比如条件概率、独立性的概念，以及随机变量、多维随机变量的概念。

#### 2. 线性代数

基于矩阵的各种运算，以及基于矩阵的理论，如PCA 方法、SVD 方法，以及 MF、NMF 方法

#### 3. 图论

#### 4. 最优化方法

最优化方法相当于机器学习中自我学习的过程，当机器知道了目标，训练后与结果存在偏差就需要迭代调整，那么最优化就是这个调整的过程。最优化方法的提出就是用更短的时间得到收敛，取得更好的效果。

总结：

![](images\数据挖掘知识清单.jpg)



### Python基础

#### NumPy

##### ndarray 对象

ndarray 实际上是多维数组的含义。在 NumPy 数组中，维数称为秩（rank），一维数组的秩为 1，二维数组的秩为 2，以此类推。在 NumPy 中，每一个线性的数组称为一个轴（axes），秩就是描述轴的数量。

##### 结构数组

类似C中结构体的定义

```python
import numpy as np
#定义类型
persontype = np.dtype({ 'names':['name', 'age', 'chinese', 'math', 'english'], 'formats':['S32','i', 'i', 'i', 'f']})
#结构数组，每个元素都是一个persontype类型
peoples = np.array([("ZhangFei",32,75,100, 90),("GuanYu",24,85,96,88.5), ("ZhaoYun",28,85,92,96.5),("HuangZhong",29,65,85,100)], dtype=persontype)
#平均年龄
ages = peoples[:]['age']
print np.mean(ages)
```

##### ufunc 运算

能对数组中每个元素进行函数操作

**连续数组的创建**

```python
x1 = np.arange(1,11,2) #等差数组，初始值、终值、步长，默认是不包括终值
x2 = np.linspace(1,9,5) #初始值、终值、元素个数，默认是包括终值的
#x1,x2 都是[1 3 5 7 9]
```

**算数运算**

通过 NumPy 可以自由地创建等差数组，同时也可以进行加、减、乘、除、求 n 次方和取余数。

```python
x1 = np.arange(1,11,2)
x2 = np.linspace(1,9,5)
print np.add(x1, x2)
print np.subtract(x1, x2)
print np.multiply(x1, x2)
print np.divide(x1, x2)
print np.power(x1, x2)
#以下两个方法结果相同
print np.remainder(x1, x2)
print np.mod(x1, x2)
```

**统计函数**

```python
import numpy as np
a = np.array([[1,2,3], [4,5,6], [7,8,9]])
#全部元素的最小值
print np.amin(a)
#amin(a,0) 是延着 axis=0 轴的最小值，也就是3个元素的最小值[1,2,3]
print np.amin(a,0)
#是延着axis=1 轴的最小值,[1,4,7]
print np.amin(a,1)
print np.amax(a)
print np.amax(a,0)
print np.amax(a,1)
```

统计最大值与最小值之差 **ptp()**

```python
a = np.array([[1,2,3], [4,5,6], [7,8,9]])
print np.ptp(a)
print np.ptp(a,0)
print np.ptp(a,1)
```

统计数组的百分位数 **percentile()**

p 的取值范围是 0-100，如果 p=0，那么就是求最小值，如果 p=50 就是求平均值，如果 p=100 就是求最大值。同样你也可以求得在 axis=0 和 axis=1 两个轴上的 p% 的百分位数。

axis=0 是跨行（纵向），axis=1 是跨列（横向）

```python
a = np.array([[1,2,3], [4,5,6], [7,8,9]])
print np.percentile(a, 50)
print np.percentile(a, 50, axis=0)
print np.percentile(a, 50, axis=1)
```

统计数组中的中位数 **median()**、平均数 **mean()**

```python
a = np.array([[1,2,3], [4,5,6], [7,8,9]])
#求中位数
print np.median(a)
print np.median(a, axis=0)
print np.median(a, axis=1)
#求平均数
print np.mean(a)
print np.mean(a, axis=0)
print np.mean(a, axis=1)
```

统计数组中的加权平均值 **average()**

```python
a = np.array([1,2,3,4])
wts = np.array([1,2,3,4])
#默认每个元素的权重是相同的
print np.average(a)
#加权平均
print np.average(a,weights=wts)
```

统计数组中的**标准差** std()、**方差 var()**

```
a = np.array([1,2,3,4])
print np.std(a)
print np.var(a)
```

#### NumPy 排序

sort(a, axis=-1, kind=‘quicksort’, order=None)

默认情况下使用的是快速排序；在 kind 里，可以指定 quicksort、mergesort、heapsort 分别表示快速排序、合并排序、堆排序。同样 axis 默认是 -1，即沿着数组的最后一个轴进行排序，也可以取不同的 axis 轴，或者 axis=None 代表采用扁平化的方式作为一个向量进行排序。另外 order 字段，对于结构化的数组可以指定按照某个字段进行排序。

```python
a = np.array([[4,3,2],[2,4,1]])
print np.sort(a)
print np.sort(a, axis=None)
print np.sort(a, axis=0)  
#[[2 3 1] [4 4 2]]
print np.sort(a, axis=1)  
#[[2 3 4] [1 2 4]]

persontype = np.dtype({ 'names':['name',  'chinese', 'math', 'english'], 'formats':['S32', 'i', 'i', 'f']})
#结构数组，每个元素都是一个persontype类型
peoples = np.array([("ZhangFei",75,100, 90),("GuanYu",85,96,88.5)], persontype)
#按总成绩排序
ranking = sorted(peoples,key=lambda x:x[1]+x[2]+x[3], reverse=True)
print(ranking)
```

### Pandas

Series 和 DataFrame 这两个核心数据结构，他们分别代表着一维的序列和二维的表结构。基于这两种数据结构，Pandas 可以对数据进行导入、清洗、处理、统计和输出。

Series 是个定长的字典序列。说是定长是因为在存储的时候，相当于两个 ndarray.

Series 有两个基本属性：index 和 values。在 Series 结构中，index 默认是 0,1,2,……递增的整数序列，当然我们也可以自己来指定索引，比如 index=[‘a’, ‘b’, ‘c’, ‘d’]。